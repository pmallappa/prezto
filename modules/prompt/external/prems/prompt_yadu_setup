# turns seconds into human readable time
# 165392 => 1d 21h 56m 32s
# https://github.com/sindresorhus/pretty-time-zsh
prompt_yadu_human_time() {
	echo -n " "
	local tmp=$1
	local days=$(( tmp / 60 / 60 / 24 ))
	local hours=$(( tmp / 60 / 60 % 24 ))
	local minutes=$(( tmp / 60 % 60 ))
	local seconds=$(( tmp % 60 ))
	(( $days > 0 )) && echo -n "${days}d "
	(( $hours > 0 )) && echo -n "${hours}h "
	(( $minutes > 0 )) && echo -n "${minutes}m "
	echo "${seconds}s"
}

# displays the exec time of the last command if set threshold was exceeded
prompt_yadu_check_cmd_exec_time() {
	local stop=$EPOCHSECONDS
	local start=${prompt_yadu_cmd_timestamp:-$stop}
	integer elapsed=$stop-$start
	(($elapsed > ${YADU_CMD_MAX_EXEC_TIME:=5})) && prompt_yadu_human_time $elapsed
}

prompt_yadu_preexec() {
	prompt_yadu_cmd_timestamp=$EPOCHSECONDS

	# shows the current dir and executed command in the title when a process is active
	print -Pn "\e]0;"
	echo -nE "$PWD:t: $2"
	print -Pn "\a"
}

# string length ignoring ansi escapes
prompt_yadu_string_length() {
	# Subtract one since newline is counted as two characters
	echo $(( ${#${(S%%)1//(\%([KF1]|)\{*\}|\%[Bbkf])}} - 1 ))
}

prompt_yadu_preprompt_render() {
	# check that no command is currently running, the prompt will otherwise be rendered in the wrong place
	[[ -n ${prompt_yadu_cmd_timestamp+x} && "$1" != "precmd" ]] && return

	# set color for git branch/dirty status, change color if dirty checking has been delayed
	local git_color=015
	[[ -n ${prompt_yadu_git_delay_dirty_check+x} ]] && git_color=red

	# construct prompt, beginning with path
	local prompt="%F{178}%~%f"
	# git info
	prompt+="%F{$git_color}${prompt_yadu_git_dirty}%f"
	# git pull/push arrows
	#prompt+="%F{cyan}${prompt_yadu_git_arrows}%f"
	# username and machine if applicable
	#prompt+=$prompt_yadu_username
	# execution time
	prompt+="%F{yellow}${prompt_yadu_cmd_exec_time}%f"

	# if executing through precmd, do not perform fancy terminal editing
	if [[ "$1" == "precmd" ]]; then
		print -P "\n${prompt}"
	else
		# only redraw if prompt has changed
		[[ "${prompt_yadu_last_preprompt}" != "${prompt}" ]] || \
				return

		# calculate length of prompt for redraw purposes
		local prompt_length=$(prompt_yadu_string_length $prompt)
		local lines=$(( $prompt_length / $COLUMNS + 1 ))

		# disable clearing of line if last char of prompt is last column of terminal
		local clr="\e[K"
		(( $prompt_length * $lines == $COLUMNS - 1 )) && clr=""

		# modify previous prompt
		print -Pn "\e7\e[${lines}A\e[1G${prompt}${clr}\e8"
	fi

	# store previous prompt for comparison
	prompt_yadu_last_preprompt=$prompt
}

prompt_yadu_precmd() {
	# store exec time for when preprompt gets re-rendered
	prompt_yadu_cmd_exec_time=$(prompt_yadu_check_cmd_exec_time)

	# by making sure that prompt_yadu_cmd_timestamp is defined here the async functions are prevented from interfering
	# with the initial preprompt rendering
	prompt_yadu_cmd_timestamp=

	# shows the full path in the title
	print -Pn '\e]0;%~\a'

	#set -x
	# get vcs info, selectively execute
	case "$(fc -ln $(($HISTCMD-1)))" in
	hg*|git*)
		zstyle ':prezto:module:vcs' run 'yes'
		;;
	default)
		zstyle ':prezto:module:vcs' run 'no'
		;;
	esac

	#set +x
	local run_vcs
	zstyle -s ':prezto:module:vcs' run 'run_vcs'
	# preform async git dirty check and fetch
	prompt_yadu_async_tasks  ${run_vcs}

	# print the preprompt
	prompt_yadu_preprompt_render "precmd"

	# remove the prompt_yadu_cmd_timestamp, indicating that precmd has completed
	unset prompt_yadu_cmd_timestamp
}

function prompt_vcs {
    #set -x

    #echo -n "%F{015}"
    if [[ -n "${my_hook_com[vcsformatted]}" ]]; then
	echo -n "${my_hook_com[vcsformatted]}"
    fi

    case ${my_hook_com[vcs]} in
	git*|hg*)
	    [[ -n "${my_hook_com[stash]}" ]] && \
		echo -n "[${my_hook_com[stash]}]"
	    if [[ -n "${my_hook_com[ahead]}" && -n "${my_hook_com[behind]}" ]];	then
		local sep="/"
	    fi
	    if [[ -n "${my_hook_com[ahead]}" || -n "${my_hook_com[behind]}" ]]; then
		echo -n "["
		echo -n "${my_hook_com[ahead]}"
		echo -n "$sep"
		echo -n "${my_hook_com[behind]}"
		echo -n "]"
	    fi

	    echo -n "${my_hook_com[branch]}"

	    [[ -n "${my_hook_com[remote]}" ]] && \
	    echo -n "${my_hook_com[remote]}"

	    [[ -n "${my_hook_com[status]}" ]] && \
		echo -n " |${my_hook_com[status]}"

	    [[ -n "${my_hook_com[action]}" ]] && \
		echo -n " ${my_hook_com[action]}"
	    ;;
	*)
	    echo -n "$vcs_info_msg_0_"
	    return
	    ;;
    esac
    #echo -n "%f"
    #set +x
}

# fastest possible way to check if repo is dirty
prompt_yadu_async_git_dirty() {
	local untracked_dirty=$2
	local umode="-unormal"
	[[ "$untracked_dirty" == "0" ]] && umode="-uno"

	cd "$1"
	#if zstyle -t ':prezto:module:vcs' run 'yes'; then
		my_hook_com=()
		vcs_info
	#	zstyle ':prezto:module:vcs' run 'no'
	#fi
	prompt_vcs
}

prompt_yadu_async_tasks() {
	run_vcs=$1

	# initialize async worker
	((!${prompt_yadu_async_init:-0})) && {
		async_start_worker "prompt_yadu" -u -n
		async_register_callback "prompt_yadu" prompt_yadu_async_callback
		prompt_yadu_async_init=1
	}

	# get the current git working tree, empty if not inside a git directory
	local working_tree="$(command git rev-parse --show-toplevel 2>/dev/null)"

	# check if the working tree changed, it is prefixed with "x" to prevent variable resolution in path
	#set -x
	if [ "${prompt_yadu_current_working_tree:-x}" != "x${working_tree}" ]; then
		# stop any running async jobs
		async_flush_jobs "prompt_yadu"

		# reset git preprompt variables, switching working tree
		unset prompt_yadu_git_dirty
		unset prompt_yadu_git_delay_dirty_check

		# set the new working tree, prefixed with "x"
		prompt_yadu_current_working_tree="x${working_tree}"
	fi

	# only perform tasks inside git working tree
	[[ "${working_tree}" != "" ]] || return

	# tell worker to do a git fetch
	#async_job "prompt_yadu" prompt_yadu_async_git_fetch $working_tree

	# if dirty checking is sufficiently fast, tell worker to check it again, or wait for timeout
	local dirty_check=$(( $EPOCHSECONDS - ${prompt_yadu_git_delay_dirty_check:-0} ))
	if (( $dirty_check > ${YADU_GIT_DELAY_DIRTY_CHECK:-1800} )); then
		run_vcs='yes'
	fi

	if [[ "${run_vcs}" == "yes" ]] ; then
		unset prompt_yadu_git_delay_dirty_check
		(( ${YADU_GIT_PULL:-1} )) &&
		# make sure working tree is not $HOME
		[[ "${working_tree}" != "$HOME" ]] &&
		# check check if there is anything to pull
		async_job "prompt_yadu" prompt_yadu_async_git_dirty $working_tree \
			$YADU_GIT_UNTRACKED_DIRTY
	fi
	#set +x
}

prompt_yadu_async_callback() {
	local job=$1
	local output=$3
	local exec_time=$4

	case "${job}" in
		prompt_yadu_async_git_dirty)
			prompt_yadu_git_dirty=$output
			prompt_yadu_preprompt_render

			# when prompt_yadu_git_delay_dirty_check is set, the git info is displayed in a different color, this is why the
			# prompt is rendered before the variable is (potentially) set
			(( $exec_time > 2 )) && prompt_yadu_git_delay_dirty_check=$EPOCHSECONDS
			;;
		prompt_yadu_async_git_fetch)
			prompt_yadu_git_arrows=$(prompt_yadu_check_git_arrows)
			prompt_yadu_preprompt_render
			;;
	esac
}

function __setup_vcs_style {
    zstyle ':vcs_info:*' formats ''
    zstyle ':vcs_info:*' actionformats '{|%s%f%c: %b|%a}'

    # This includes git-svn, hg-svn, hg-git etc
    zstyle ':vcs_info:(hg*|git*):*' get-revision true
    zstyle ':vcs_info:(hg*|git*):*' check-for-changes true

    ### Mark individual style
    () {
	zstyle ':prezto:module:git:info' verbose 'yes'

	zstyle ':prezto:module:(git*|hg*):vcsformatted' format "| %%F{039}%v%%f"
	zstyle ':prezto:module:(git*|hg*):info:added' format  '%%F{40} ●%%f '
	zstyle ':prezto:module:(git*|hg*):info:ahead' format  '%%F{185}+%A%%f'
	zstyle ':prezto:module:(git*|hg*):info:behind' format  '%%F{213}-%B%%f'
	zstyle ':prezto:module:(git*|hg*):info:branch' format '%%F{015}%%f: %%F{111}%b%%f'
	zstyle ':prezto:module:(git*|hg*):info:remote' format ' => %%F{67}%R%%f'
	zstyle ':prezto:module:(git*|hg*):info:commit' format ':%.7c'
	zstyle ':prezto:module:(git*|hg*):info:deleted' format  ''
	zstyle ':prezto:module:(git*|hg*):info:modified' format  '%%F{197} ●%%f '
	zstyle ':prezto:module:(git*|hg*):info:position' format ':%p'
	zstyle ':prezto:module:(git*|hg*):info:renamed' format  '%%F{207} ●%%f'
	zstyle ':prezto:module:(git*|hg*):info:stashed' format  '%%B%%F{141}*%%f%%b'
	zstyle ':prezto:module:(git*|hg*):info:unmerged' format  '═ '
	zstyle ':prezto:module:(git*|hg*):info:untracked' format '%%F{95} ●%%f '
	zstyle ':prezto:module:git:info:action' format '[%%F{226}%s%%f] '

	zstyle ':prezto:module:(git*|hg*):info:keys' format \
	    'ahead'     '%A' \
	    'behind'    '%B' \
	    'added'     '%a' \
	    'deleted'   '%d' \
	    'modified'  '%m' \
	    'renamed'   '%r' \
	    'untracked' '%u' \
	    'branch'    '%b' \
	    'remote'    '%R' \
	    'stash'     '%S' \
	    'status'    '%U%C%a%d%m%r%u' \
	    'action'    '%s'
    }

    ## Mercurial specific
    () {
	# VCS name in prompt
	zstyle ':prezto:module:hg*:vcs' format "| %%F{039}%v%%f"
    }

    ## Git specific
    () {
	zstyle ':prezto:module:git*:vcs' format '| %%F{140}%v%%f'
    }
}

function prompt_host {
    local hostcolor
    local host="$(hostname)"
    fg=16
    case $host in
	pmallappa-server)
            bg=10
	    fg=16;;
	pmallappa-laptop)
	    bg=166;;
	pmallappa-test)
            bg=cyan;;
	imac* | iMac*)
	    bg=magenta ;;
	*-vm)
            bg=$(($RANDOM%256)) ;;
	*)
            bg=gray  ;;
    esac
    #CURRENT_BG="$bg"
    echo -n "%F{$bg}$host%f"
    if [[ -n "$SCHROOT_SESSION_ID" ]]; then
	echo -n "%F{red} [chroot]%f"
    fi
}

function build_rprompt() {
    local symbols
    local j
    symbols=()
        #[[ $RETVAL -ne 0 ]] && symbols+="%{%F{red}%}✘ [$RETVAL]"
    [[ $RETVAL -ne 0 ]] && symbols+="%B%F{red}X[$RETVAL]%f%b"
    [[ $UID -eq 0 ]] && symbols+="%F{yellow}ROOT%f"
    [[ $(jobs -l | wc -l) -gt 0 ]] && j="& "
    [[ -n "$j" ]] && echo -n "%F{208} $j%f"
    [[ -n "$symbols" ]] && echo -n "%F{247} $symbols%f"
}

prompt_yadu_setup() {
	# prevent percentage showing up
	# if output doesn't end with a newline
	export PROMPT_EOL_MARK=''

	prompt_opts=(cr subst percent)

	zmodload zsh/datetime
	autoload -Uz add-zsh-hook
	autoload -Uz vcs_info
	autoload -Uz async && async
	autoload -Uz colors && colors

	add-zsh-hook precmd prompt_yadu_precmd
	add-zsh-hook preexec prompt_yadu_preexec

	__setup_vcs_style

	# show username@host if logged in through SSH
	[[ "$SSH_CONNECTION" != '' ]] && prompt_yadu_username=' %F{242}%n@$(prompt_host)%f'

	# show username@host if root, with username in white
	[[ $UID -eq 0 ]] && prompt_yadu_username=' %F{white}%n%f%F{242}@%$(prompt_host)%f'

	# prompt turns red if the previous command didn't exit with 0
	#PROMPT="%(?.%F{magenta}.%F{red})${YADU_PROMPT_SYMBOL:->>>}%f "
	YADU_PROMPT_SYMBOL="$(prompt_host) %B%F{red}>%F{yellow}>%F{green}>%f%b "
	PROMPT="%(?.%F{magenta}.%F{red})${YADU_PROMPT_SYMBOL:->>>}%f"
	RPROMPT='$(build_rprompt)'
}

prompt_yadu_setup "$@"
